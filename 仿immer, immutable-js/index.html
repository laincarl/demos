<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>仿immer, immutable-js</title>
</head>

<body>
  <figure>
    <figcaption>目标：</figcaption>
    <pre>
      <code>       
        const obj = {
          a: 5,
          b: [1, 2]
        }
        const obj2 = produce(obj, (state) => {
          state.a = 6;
        })
        obj !== obj2
        obj.b === obj2.b
      </code>
    </pre>
  </figure>
  <script>
    const proxys = new Map();
    const objects = new Map();
    function isObject(something) {
      return something instanceof Object;
    }
    function isProxy(something) {
      return objects.has(something)
    }
    function setModify(target) {
      let parent = target;
      while (parent) {
        const attrs = objects.get(target);
        if (attrs.modify) {
          break;
        }
        Object.assign(attrs, { modify: true });
        parent = attrs.parent;
      }

    }
    function cloneParent() {

    }
    function cloneParents(target) {
      let object = target;
      while (object) {
        const attrs = objects.get(target);
        const { clone, key, parent } = attrs;
        if (clone) {
          break;
        }
        const cloneObject = { ...target };
        // parent指向的是之前的子，所以这里将parent指向克隆过的子
        if (parent && key) {
          parent[key] = cloneObject
        }
        Object.assign(attrs, { clone: cloneObject });
        object = parent;
      }
    }
    function lazyProxy(object, parent, key) {
      const proxy = new Proxy(object, {
        get: function (target, propKey, receiver) {
          console.log(`get:${propKey}`, target);
          const current = target[propKey];
          console.log(current)
          // 是对象才进行处理
          if (isObject(current)) {
            // 如果没有设置代理，就设置，以让其子操作时可以被监测到
            if (!isProxy(current)) {
              const proxy = lazyProxy(current, target, propKey)
              console.log('为子设置代理', propKey)
              return proxy;
            } else {
              console.log('第二次获取', propKey)
              // 获取时,这时判断,如果已经更改过,就返回代理对象,否则返回原对象
              const attrs = objects.get(current);
              return attrs.proxy
              // return attrs.modify ? attrs.clone : attrs.source;
            }
          } else {
            console.log('获取普通属性', propKey);
            return Reflect.get(target, propKey, receiver);
          }
        },
        // 这里获取到的targe是克隆过的对象        
        set: function (target, propKey, value, receiver) {
          if (target[propKey] !== value) {
            // console.log(target, objects.get(target))
            console.log('set', '开始克隆', propKey);
            const { parent, key } = objects.get(target);
            const clone = { ...target };
            clone[propKey] = value;
            Object.assign(objects.get(target), { clone })
            // 递归克隆祖先元素
            if (parent) {
              console.log('递归克隆祖先元素', clone)
              // TODO: 解决更改parent
              parent[key] = clone;
              cloneParents(parent);
            }
            console.log(`setting ${propKey}!`);
            return true;
          }
          console.log('=')
          return Reflect.set(target, propKey, value, receiver);
        }
      });
      objects.set(object, {
        source: object,
        proxy,
        modify: false,
        clone: false,
        parent,
        key,
      });
      return proxy
    }
    const source = {
      a: 1,
      b: {
        c: 1
      }
    }

    function produce(state, fn) {
      const proxy = lazyProxy(state);
      fn(proxy)
      const { clone, source } = objects.get(state)
      return clone ? clone : source;
    }
    const result = produce(source, (draft) => {
      // draft.a = 5;
      // console.log(draft.b.c, '获取')
      // draft.b.c = 5;
      draft.b.c = 6;
    })
    console.log('source', source)
    console.log('result', result)
    // console.log(source.b, result.b)
    console.assert(result === source, "对象不相等");
    console.assert(result.b === source.b, "子属性不相等");
  </script>
</body>

</html>